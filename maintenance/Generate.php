<?php

namespace MediaWiki\Extension\TrustedXFF;

use MediaWiki\Maintenance\Maintenance;
use Wikimedia\IPSet;
use Wikimedia\IPUtils;

// @codeCoverageIgnoreStart
require_once getenv( 'MW_INSTALL_PATH' ) !== false
	? getenv( 'MW_INSTALL_PATH' ) . '/maintenance/Maintenance.php'
	: __DIR__ . '/../../../maintenance/Maintenance.php';
// @codeCoverageIgnoreEnd

class Generate extends Maintenance {
	public function __construct() {
		parent::__construct();
		$this->addDescription( 'Generates the PHP/JSON XFF file from the trusted-hosts.txt file' );
		$this->addOption( 'outdir', 'The output directory, default ' . dirname( __DIR__ ) );

		// This script does not require the extension to be installed
	}

	public function execute() {
		$outDir = $this->getOption( 'outdir', dirname( __DIR__ ) );
		$inFileName = dirname( __DIR__ ) . '/trusted-hosts.txt';
		$inFile = fopen( $inFileName, 'r' );
		if ( !$inFile ) {
			$this->fatalError( "Unable to open input file \"$inFileName\"\n" );
		}

		$lineNum = 0;
		$ranges = [];
		$names = [];

		while ( !feof( $inFile ) ) {
			$line = fgets( $inFile );
			$lineNum++;
			if ( $line === false ) {
				break;
			}
			// Remove comment
			$hashPos = strpos( $line, '#' );
			if ( $hashPos !== false ) {
				$line = substr( $line, 0, $hashPos );
			}
			// Strip spaces
			$line = trim( $line );

			if ( $line === '' ) {
				// Comment or blank line
				continue;
			}

			[ $start, ] = IPUtils::parseRange( $line );
			if ( $start === false ) {
				// Try DNS
				$names[] = [ $lineNum, $line ];
				continue;
			}
			$ranges[] = $line;
		}

		$this->output( count( $names ) . " DNS queries to do...\n" );

		foreach ( $names as $i => $nameInfo ) {
			[ $lineNum, $name ] = $nameInfo;
			$ips = gethostbynamel( $name );
			if ( $ips === false ) {
				$this->output( "Not a valid host or IP address on line $lineNum: $name\n" );
			} else {
				$ranges = array_merge( $ranges, $ips );
			}
			$this->showProgress( $i, count( $names ) );
			// Don't DoS the recursor
			usleep( 10000 );
		}
		$this->output( "\n" );

		natsort( $ranges );
		$ranges = array_values( array_unique( $ranges ) );

		$header = sprintf(
			"Generated by %s/%s on %s;\nNote this file is deprecated in favour of trusted-hosts.json.",
			basename( __DIR__ ),
			basename( __FILE__ ),
			gmdate( 'c' )
		);

		$out = "<" . "?php\n" . preg_replace( '/^/m', '# ', $header ) . "\nreturn [\n";
		foreach ( $ranges as $range ) {
			$out .= "\t" . var_export( $range, true ) . ",\n";
		}
		$out .= "];\n";
		file_put_contents(
			"$outDir/trusted-hosts.php",
			$out
		);

		file_put_contents(
			"$outDir/trusted-hosts.json",
			json_encode( new IPSet( $ranges ) )
		);

		$count = count( $ranges );
		$this->output( "$count ips or ranges listed\n" );
	}

	/**
	 * @param int $current
	 * @param int $total
	 */
	private function showProgress( $current, $total ) {
		$length = 50;
		$dots = intval( ( $current + 1 ) / $total * $length );
		printf( "%6.2f%%  [" .
			str_repeat( '=', $dots ) . str_repeat( '.', $length - $dots ) . "]\r",
			( $current + 1 ) / $total * 100
		);
	}

	public function canExecuteWithoutLocalSettings(): bool {
		return true;
	}
}

// @codeCoverageIgnoreStart
$maintClass = Generate::class;
require_once RUN_MAINTENANCE_IF_MAIN;
// @codeCoverageIgnoreEnd
